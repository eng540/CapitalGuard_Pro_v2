<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>CapitalGuard Terminal - Ù…Ù†Ø´Ø¦ Ø§Ù„ØªÙˆØµÙŠØ§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        :root {
            --bg-color: var(--tg-theme-bg-color, #1c1c1e);
            --card-bg: var(--tg-theme-secondary-bg-color, #2c2c2e);
            --text-color: var(--tg-theme-text-color, #ffffff);
            --hint-color: var(--tg-theme-hint-color, #8e8e93);
            --button-color: var(--tg-theme-button-color, #0a84ff);
            --button-text: var(--tg-theme-button-text-color, #ffffff);
            --green: #32d74b; --red: #ff453a; --orange: #ff9f0a; --blue: #0a84ff;
            --border: rgba(128, 128, 128, 0.2); --switcher-bg: #000000;
            --input-bg: rgba(0, 0, 0, 0.2);
            --success: #32d74b; --warning: #ff9f0a; --danger: #ff453a;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            margin: 0;
            padding: 16px;
            padding-bottom: 120px;
            -webkit-tap-highlight-color: transparent;
            line-height: 1.5;
        }

        /* ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„ØªØµÙ…ÙŠÙ… Ø§Ù„Ø¹Ø§Ù…Ø© */
        .section {
            background-color: var(--card-bg);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 16px;
            border: 1px solid var(--border);
            transition: all 0.3s ease;
        }

        .section:hover {
            border-color: rgba(128, 128, 128, 0.4);
        }

        .input-label {
            font-size: 0.75rem;
            color: var(--hint-color);
            margin-bottom: 8px;
            display: block;
            font-weight: 600;
            letter-spacing: 0.3px;
            text-transform: uppercase;
        }

        input, textarea, select {
            width: 100%;
            background: var(--input-bg);
            border: 1px solid var(--border);
            color: var(--text-color);
            padding: 14px 16px;
            border-radius: 12px;
            font-size: 1rem;
            font-family: inherit;
            transition: all 0.2s ease;
        }

        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: var(--button-color);
            box-shadow: 0 0 0 2px rgba(10, 132, 255, 0.2);
        }

        /* ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„Ø£Ø²Ø±Ø§Ø± */
        .btn-group {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
        }

        .btn-select {
            flex: 1;
            padding: 14px 12px;
            border-radius: 12px;
            border: 1px solid var(--border);
            background: var(--bg-color);
            color: var(--hint-color);
            font-weight: 600;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            position: relative;
            overflow: hidden;
        }

        .btn-select::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: left 0.5s;
        }

        .btn-select:active::before {
            left: 100%;
        }

        .btn-select.active-long {
            background: rgba(50, 215, 75, 0.15);
            border-color: var(--green);
            color: var(--green);
            box-shadow: 0 4px 12px rgba(50, 215, 75, 0.2);
        }

        .btn-select.active-short {
            background: rgba(255, 69, 58, 0.15);
            border-color: var(--red);
            color: var(--red);
            box-shadow: 0 4px 12px rgba(255, 69, 58, 0.2);
        }

        .btn-select.active-type {
            background: rgba(10, 132, 255, 0.15);
            border-color: var(--button-color);
            color: var(--button-color);
            box-shadow: 0 4px 12px rgba(10, 132, 255, 0.2);
        }

        /* ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„Ø³ÙˆÙŠØªØ´Ø± */
        .market-switch {
            display: flex;
            background: var(--switcher-bg);
            padding: 6px;
            border-radius: 14px;
            margin-bottom: 24px;
            border: 1px solid var(--border);
        }

        .market-opt {
            flex: 1;
            text-align: center;
            padding: 12px 8px;
            border-radius: 10px;
            font-weight: 700;
            font-size: 0.85rem;
            color: var(--hint-color);
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        .market-opt.active {
            background: var(--card-bg);
            color: var(--text-color);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
            transform: translateY(-1px);
        }

        .market-opt.active.futures { color: var(--orange); }
        .market-opt.active.spot { color: var(--blue); }

        /* ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„Ø±Ø£Ø³ */
        .header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .asset-input {
            background: transparent;
            border: none;
            color: var(--text-color);
            font-size: 1.6rem;
            font-weight: 800;
            width: 100%;
            text-transform: uppercase;
            padding: 0;
            letter-spacing: 0.5px;
        }

        .live-price {
            color: var(--green);
            font-weight: bold;
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 1.1rem;
            background: rgba(50, 215, 75, 0.1);
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid rgba(50, 215, 75, 0.3);
        }

        /* ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„Ø±Ø§ÙØ¹Ø© Ø§Ù„Ù…Ø§Ù„ÙŠØ© */
        .leverage-section {
            transition: all 0.4s ease;
            overflow: hidden;
        }

        .leverage-container {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }

        .leverage-val {
            font-weight: bold;
            color: var(--orange);
            width: 50px;
            text-align: center;
            background: rgba(255, 159, 10, 0.1);
            padding: 6px;
            border-radius: 6px;
            border: 1px solid rgba(255, 159, 10, 0.3);
        }

        input[type=range] {
            width: 100%;
            height: 6px;
            background: #444;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: var(--orange);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        /* ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„Ø£Ù‡Ø¯Ø§Ù */
        .targets-section {
            position: relative;
        }

        .target-row {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 12px;
            background: rgba(128,128,128,0.08);
            padding: 12px;
            border-radius: 12px;
            animation: slideIn 0.3s ease-out;
            transition: all 0.3s ease;
            border: 1px solid transparent;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .target-row:hover {
            background: rgba(128,128,128,0.12);
            border-color: var(--border);
        }

        .target-row.error {
            background: rgba(255, 69, 58, 0.1);
            border: 1px solid var(--red);
            animation: shake 0.5s ease-in-out;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        .tp-badge {
            background: var(--button-color);
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: bold;
            flex-shrink: 0;
            box-shadow: 0 2px 8px rgba(10, 132, 255, 0.3);
        }

        .tp-remove {
            color: var(--red);
            padding: 8px;
            cursor: pointer;
            font-size: 1.3rem;
            transition: transform 0.2s ease;
        }

        .tp-remove:active {
            transform: scale(0.9);
        }

        /* ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„Ø±Ù‚Ø§Ø¦Ù‚ Ø§Ù„Ø°ÙƒÙŠØ© */
        .smart-chips {
            display: flex;
            gap: 10px;
            overflow-x: auto;
            padding: 16px 0;
            margin: 0 -16px;
            padding-left: 16px;
            scrollbar-width: none;
        }

        .smart-chips::-webkit-scrollbar {
            display: none;
        }

        .chip {
            background: var(--bg-color);
            border: 1px solid var(--border);
            color: var(--hint-color);
            padding: 10px 16px;
            border-radius: 24px;
            font-size: 0.85rem;
            white-space: nowrap;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
            flex-shrink: 0;
        }

        .chip:active {
            transform: scale(0.95);
        }

        .chip-blue {
            border-color: var(--button-color);
            color: var(--button-color);
            background: rgba(10, 132, 255, 0.1);
        }

        .chip:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        /* ØªØ­Ø³ÙŠÙ†Ø§Øª Ø´Ø±ÙŠØ· Ø§Ù„ØªÙ‚Ø¯Ù… */
        .progress-container {
            height: 8px;
            background: #444;
            border-radius: 4px;
            margin: 16px 0;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            width: 0%;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            background: linear-gradient(90deg, var(--orange), var(--green));
            position: relative;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .progress-text {
            font-size: 0.8rem;
            text-align: right;
            margin-top: 8px;
            font-weight: bold;
            transition: color 0.3s ease;
        }

        /* ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„Ù‚Ù†ÙˆØ§Øª */
        .channel-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 12px;
        }

        .channel-chip {
            background: var(--bg-color);
            border: 1px solid var(--border);
            padding: 12px 16px;
            border-radius: 16px;
            font-size: 0.85rem;
            color: var(--hint-color);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
            text-align: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .channel-chip::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: left 0.5s;
        }

        .channel-chip:active::before {
            left: 100%;
        }

        .channel-chip.selected {
            background: var(--button-color);
            border-color: var(--button-color);
            color: white;
            box-shadow: 0 4px 16px rgba(10, 132, 255, 0.3);
            transform: translateY(-2px);
        }

        .channel-chip.inactive {
            opacity: 0.6;
            border-style: dashed;
        }

        .channel-chip.inactive.selected {
            background: rgba(10, 132, 255, 0.5);
        }

        /* Ø²Ø± Ø§Ù„Ù†Ø´Ø± Ø§Ù„Ù…Ø­Ø³Ù† */
        .publish-btn {
            width: 92%;
            background: var(--button-color);
            color: var(--button-text);
            border: none;
            padding: 18px;
            border-radius: 16px;
            font-size: 1.1rem;
            font-weight: 700;
            position: fixed;
            bottom: 20px;
            left: 4%;
            box-shadow: 0 8px 32px rgba(10, 132, 255, 0.4);
            cursor: pointer;
            z-index: 1000;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            letter-spacing: 0.5px;
        }

        .publish-btn:active {
            transform: scale(0.98) translateY(2px);
            box-shadow: 0 4px 16px rgba(10, 132, 255, 0.3);
        }

        .publish-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: #555;
            transform: none;
            box-shadow: none;
        }

        .publish-btn.loading {
            background: linear-gradient(90deg, var(--button-color), #4dabf7, var(--button-color));
            background-size: 200% 100%;
            animation: loading 1.5s infinite;
        }

        @keyframes loading {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        /* ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„ØªÙ†Ø¨ÙŠÙ‡Ø§Øª */
        .alert {
            padding: 16px;
            border-radius: 12px;
            margin-bottom: 16px;
            border: 1px solid;
            animation: slideDown 0.3s ease-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .alert-success {
            background: rgba(50, 215, 75, 0.1);
            border-color: var(--green);
            color: var(--green);
        }

        .alert-warning {
            background: rgba(255, 159, 10, 0.1);
            border-color: var(--orange);
            color: var(--orange);
        }

        .alert-danger {
            background: rgba(255, 69, 58, 0.1);
            border-color: var(--red);
            color: var(--red);
        }

        /* ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„ØªØ­Ù…ÙŠÙ„ */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            backdrop-filter: blur(5px);
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid transparent;
            border-top: 3px solid var(--button-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø© */
        @media (max-width: 380px) {
            .section {
                padding: 16px;
            }
            
            .btn-select {
                padding: 12px 8px;
                font-size: 0.8rem;
            }
            
            .channel-grid {
                grid-template-columns: 1fr;
            }
        }

        /* ØªØ£Ø«ÙŠØ±Ø§Øª Ø®Ø§ØµØ© */
        .floating-label {
            position: relative;
            margin-bottom: 20px;
        }

        .floating-label input {
            padding-top: 20px;
        }

        .floating-label .label-text {
            position: absolute;
            top: 8px;
            left: 16px;
            font-size: 0.75rem;
            color: var(--hint-color);
            transition: all 0.3s ease;
            pointer-events: none;
        }

        .floating-label input:focus + .label-text,
        .floating-label input:not(:placeholder-shown) + .label-text {
            top: 2px;
            font-size: 0.7rem;
            color: var(--button-color);
        }
    </style>
</head>
<body>
    <div id="loadingOverlay" class="loading-overlay" style="display: none;">
        <div class="spinner"></div>
    </div>

    <div id="alertContainer"></div>

    <!-- Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ -->
    <div class="section" id="inputMethodSection">
        <h3 style="margin-bottom: 16px;">ğŸš€ Ø·Ø±ÙŠÙ‚Ø© Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªÙˆØµÙŠØ©</h3>
        <div class="btn-group">
            <div class="btn-select active-type" onclick="setInputMethod('interactive')">
                ğŸ“± ØªÙØ§Ø¹Ù„ÙŠ
            </div>
            <div class="btn-select" onclick="setInputMethod('quick')">
                âš¡ Ø³Ø±ÙŠØ¹
            </div>
            <div class="btn-select" onclick="setInputMethod('editor')">
                ğŸ“ Ù…Ø­Ø±Ø±
            </div>
        </div>
    </div>

    <!-- Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ø³Ø±ÙŠØ¹/Ø§Ù„Ù…Ø­Ø±Ø± -->
    <div class="section" id="textInputSection" style="display: none;">
        <div id="textInputContent"></div>
        <button class="publish-btn" onclick="parseTextInput()" style="position: relative; margin-top: 16px;">
            ØªØ­Ù„ÙŠÙ„ ÙˆØ§Ù„Ù…ØªØ§Ø¨Ø¹Ø©
        </button>
    </div>

    <!-- Ø§Ù„ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„ØªÙØ§Ø¹Ù„ÙŠØ© -->
    <div id="interactiveInterface" style="display: none;">
        <!-- Ø§Ù„Ø³ÙˆÙ‚ -->
        <div class="market-switch">
            <div class="market-opt active futures" onclick="setMarket('FUTURES')">Ø§Ù„Ø¹Ù‚ÙˆØ¯ âš¡</div>
            <div class="market-opt" onclick="setMarket('SPOT')">Ø³Ø¨ÙˆØª ğŸ’</div>
        </div>

        <!-- Ø§Ù„Ø£ØµÙ„ -->
        <div class="section">
            <div class="header-row">
                <div style="flex: 1;">
                    <label class="input-label">Ø²ÙˆØ¬ Ø§Ù„ØªØ¯Ø§ÙˆÙ„</label>
                    <input type="text" class="asset-input" id="asset" value="BTCUSDT" placeholder="SYMBOL" 
                           oninput="debounceFetchPrice()" onkeyup="validateAsset(this.value)">
                </div>
                <div style="text-align: left;">
                    <div class="input-label">Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø­ÙŠ</div>
                    <div class="live-price" id="livePrice">...</div>
                </div>
            </div>
            <div id="assetSuggestions" class="smart-chips" style="margin-top: 12px;"></div>
        </div>

        <!-- Ø§Ù„Ø§ØªØ¬Ø§Ù‡ ÙˆÙ†ÙˆØ¹ Ø§Ù„Ø·Ù„Ø¨ -->
        <div class="section">
            <div class="btn-group">
                <div class="btn-select active-long" onclick="setSide('LONG')">ğŸŸ¢ Ø´Ø±Ø§Ø¡</div>
                <div class="btn-select" onclick="setSide('SHORT')">ğŸ”´ Ø¨ÙŠØ¹</div>
            </div>
            <div class="btn-group">
                <div class="btn-select active-type" onclick="setType('LIMIT')">Limit</div>
                <div class="btn-select" onclick="setType('MARKET')">Market</div>
                <div class="btn-select" onclick="setType('STOP')">Stop</div>
            </div>
            
            <!-- Ø§Ù„Ø±Ø§ÙØ¹Ø© Ø§Ù„Ù…Ø§Ù„ÙŠØ© -->
            <div class="leverage-section" id="leverageSection">
                <div style="margin-top: 20px;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <label class="input-label">Ø§Ù„Ø±Ø§ÙØ¹Ø© Ø§Ù„Ù…Ø§Ù„ÙŠØ©</label>
                        <span class="leverage-val" id="levVal">20x</span>
                    </div>
                    <div class="leverage-container">
                        <input type="range" id="leverage" min="1" max="125" value="20" 
                               oninput="updateLeverage(this.value)">
                    </div>
                </div>
            </div>
        </div>

        <!-- Ø§Ù„Ø£Ø³Ø¹Ø§Ø± -->
        <div class="section">
            <div class="floating-label">
                <input type="number" id="entry" placeholder=" " oninput="runFullValidation()">
                <span class="label-text" id="entryLabel">Ø³Ø¹Ø± Ø§Ù„Ø¯Ø®ÙˆÙ„</span>
            </div>
            
            <div class="floating-label" style="margin-bottom: 0;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                    <span class="label-text">ÙˆÙ‚Ù Ø§Ù„Ø®Ø³Ø§Ø±Ø©</span>
                    <span class="label-text" id="riskLabel" style="color: var(--red);">0.00% Ù…Ø®Ø§Ø·Ø±Ø©</span>
                </div>
                <input type="number" id="sl" placeholder=" " style="border-color: rgba(255, 69, 58, 0.5);" 
                       oninput="runFullValidation()">
            </div>
        </div>

        <!-- Ø§Ù„Ø£Ù‡Ø¯Ø§Ù -->
        <div class="section targets-section">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                <label class="input-label" style="margin:0;">Ø§Ù„Ø£Ù‡Ø¯Ø§Ù</label>
                <div class="progress-text" id="totalPercentText">Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹: 0%</div>
            </div>
            <div class="progress-container">
                <div class="progress-fill" id="totalPercentBar"></div>
            </div>
            
            <div id="targetsContainer" class="target-container" style="margin: 20px 0;"></div>
            
            <div class="smart-chips">
                <div class="chip chip-blue" onclick="addManualTarget()">+ Ø¥Ø¶Ø§ÙØ© Ù‡Ø¯Ù</div>
                <div class="chip" onclick="smartCalc(1)">+1%</div>
                <div class="chip" onclick="smartCalc(2)">+2%</div>
                <div class="chip" onclick="smartCalc(5)">+5%</div>
                <div class="chip" onclick="promptCustomCalc()">Ù†Ø³Ø¨Ø© Ù…Ø®ØµØµØ©</div>
                <div class="chip" onclick="calcRR(1)">R:R 1:1</div>
                <div class="chip" onclick="calcRR(2)">R:R 1:2</div>
            </div>
        </div>

        <!-- Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø§Øª ÙˆØ§Ù„Ù‚Ù†ÙˆØ§Øª -->
        <div class="section">
            <div class="floating-label">
                <textarea id="notes" rows="2" placeholder=" "></textarea>
                <span class="label-text">Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø§Øª / Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ©</span>
            </div>
            
            <div style="margin-top: 24px;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 16px;">
                    <label class="input-label">Ø§Ù„Ù†Ø´Ø± ÙÙŠ Ø§Ù„Ù‚Ù†ÙˆØ§Øª</label>
                    <label class="input-label" style="color: var(--button-color); cursor: pointer;" 
                           onclick="toggleAllChannels()">ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ÙƒÙ„</label>
                </div>
                <div class="channel-grid" id="channelGrid">
                    <div class="channel-chip" style="grid-column: 1 / -1; text-align: center;">
                        Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù‚Ù†ÙˆØ§Øª...
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Ø²Ø± Ø§Ù„Ù†Ø´Ø± -->
    <button class="publish-btn" id="submitBtn" onclick="publishSignal()">
        ğŸš€ Ù†Ø´Ø± Ø§Ù„ØªÙˆØµÙŠØ©
    </button>

    <script>
        // ==============================================================================
        // 1. INITIALIZATION & STATE MANAGEMENT
        // ==============================================================================

        const tg = window.Telegram.WebApp;
        let appState = {
            currentMarket: 'FUTURES',
            currentSide: 'LONG',
            currentType: 'LIMIT',
            currentMethod: 'interactive',
            targetCount: 0,
            livePriceVal: 0,
            draftData: {},
            selectedChannels: new Set(),
            recentAssets: [],
            fetchTimeout: null,
            priceUpdateInterval: null
        };

        // Initialize the application
        function initializeApp() {
            console.log('ğŸš€ Initializing CapitalGuard WebApp...');
            
            // Telegram WebApp setup
            tg.expand();
            tg.ready();
            
            // Validate authentication
            if (!tg.initData && !tg.initDataUnsafe) {
                showAlert('âš ï¸ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù…ØµØ§Ø¯Ù‚Ø©', 'ÙŠØ±Ø¬Ù‰ ÙØªØ­ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ù…Ù† Ø®Ù„Ø§Ù„ Telegram Ù…Ø¨Ø§Ø´Ø±Ø©', 'danger');
                return;
            }

            // Start the application based on initial method
            setupInputMethod('interactive');
            
            // Load initial data
            loadInitialData();
            
            // Start price updates
            startPriceUpdates();
            
            console.log('âœ… WebApp initialized successfully');
        }

        // Load initial data
        async function loadInitialData() {
            showLoading(true);
            try {
                await Promise.all([
                    fetchChannels(),
                    fetchRecentAssets(),
                    fetchPrice('BTCUSDT')
                ]);
            } catch (error) {
                console.error('Error loading initial data:', error);
                showAlert('âš ï¸ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„', 'ØªØ¹Ø°Ø± ØªØ­Ù…ÙŠÙ„ Ø¨Ø¹Ø¶ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª', 'warning');
            }
            showLoading(false);
        }

        // ==============================================================================
        // 2. INPUT METHOD HANDLING
        // ==============================================================================

        function setInputMethod(method) {
            appState.currentMethod = method;
            
            // Update UI
            document.querySelectorAll('.btn-select').forEach(btn => {
                btn.classList.remove('active-type');
            });
            event.target.classList.add('active-type');
            
            setupInputMethod(method);
        }

        function setupInputMethod(method) {
            const methodSection = document.getElementById('inputMethodSection');
            const textInputSection = document.getElementById('textInputSection');
            const interactiveInterface = document.getElementById('interactiveInterface');
            
            // Hide all sections first
            textInputSection.style.display = 'none';
            interactiveInterface.style.display = 'none';
            
            switch(method) {
                case 'interactive':
                    interactiveInterface.style.display = 'block';
                    initializeInteractiveMode();
                    break;
                    
                case 'quick':
                    textInputSection.style.display = 'block';
                    setupQuickInputMode();
                    break;
                    
                case 'editor':
                    textInputSection.style.display = 'block';
                    setupEditorMode();
                    break;
            }
        }

        function setupQuickInputMode() {
            const content = `
                <h3 style="margin-bottom: 16px;">âš¡ ÙˆØ¶Ø¹ Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ø³Ø±ÙŠØ¹</h3>
                <p style="color: var(--hint-color); margin-bottom: 16px; font-size: 0.9rem;">
                    Ø£Ø¯Ø®Ù„ Ø§Ù„ØªÙˆØµÙŠØ© ÙÙŠ Ø³Ø·Ø± ÙˆØ§Ø­Ø¯ Ø¨Ø§Ù„ØªÙ†Ø³ÙŠÙ‚:<br>
                    <code style="background: var(--bg-color); padding: 8px 12px; border-radius: 8px; display: block; margin: 8px 0;">
                    Ø§Ù„Ø±Ù…Ø² Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø§Ù„ÙˆÙ‚Ù Ø§Ù„Ø£Ù‡Ø¯Ø§Ù...
                    </code>
                </p>
                <div class="floating-label">
                    <textarea id="quickInput" rows="4" placeholder=" "></textarea>
                    <span class="label-text">Ø£Ø¯Ø®Ù„ Ø§Ù„ØªÙˆØµÙŠØ© Ø§Ù„ÙƒØ§Ù…Ù„Ø©</span>
                </div>
                <div style="margin-top: 12px;">
                    <strong>Ø£Ù…Ø«Ù„Ø©:</strong>
                    <div style="font-size: 0.8rem; color: var(--hint-color); margin-top: 8px;">
                        â€¢ <code>BTCUSDT LONG 90000 89000 91000 92000 93000</code><br>
                        â€¢ <code>ETHUSDT SHORT 3500 3600 3400 3300 3200</code>
                    </div>
                </div>
            `;
            document.getElementById('textInputContent').innerHTML = content;
        }

        function setupEditorMode() {
            const content = `
                <h3 style="margin-bottom: 16px;">ğŸ“ ÙˆØ¶Ø¹ Ø§Ù„Ù…Ø­Ø±Ø± Ø§Ù„Ù†ØµÙŠ</h3>
                <p style="color: var(--hint-color); margin-bottom: 16px; font-size: 0.9rem;">
                    Ø§Ù„ØµÙ‚ Ø§Ù„ØªÙˆØµÙŠØ© Ø¨Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ØªØ§Ù„ÙŠ (ÙƒÙ„ Ù…Ø¹Ù„ÙˆÙ…Ø© ÙÙŠ Ø³Ø·Ø±):
                </p>
                <div class="floating-label">
                    <textarea id="editorInput" rows="6" placeholder=" "></textarea>
                    <span class="label-text">Ø§Ù„ØµÙ‚ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù‡Ù†Ø§</span>
                </div>
                <div style="margin-top: 12px;">
                    <strong>Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨:</strong>
                    <pre style="background: var(--bg-color); padding: 12px; border-radius: 8px; font-size: 0.8rem; margin-top: 8px; color: var(--text-color);">
Asset: BTCUSDT
Side: LONG  
Entry: 90000
SL: 89000
TPs: 91000 92000 93000
Notes: ØªÙˆØµÙŠØ© Ø´Ø±Ø·ÙŠØ©
Leverage: 20</pre>
                </div>
            `;
            document.getElementById('textInputContent').innerHTML = content;
        }

        function initializeInteractiveMode() {
            // Add initial target
            addManualTarget();
            
            // Setup asset suggestions
            setupAssetSuggestions();
            
            // Initial validation
            runFullValidation();
        }

        // ==============================================================================
        // 3. ASSET & PRICE MANAGEMENT
        // ==============================================================================

        async function fetchRecentAssets() {
            try {
                // This would call your backend API
                // const response = await fetch('/api/webapp/recent-assets?initData=' + encodeURIComponent(getInitData()));
                // const data = await response.json();
                
                // Mock data for demonstration
                appState.recentAssets = ['BTCUSDT', 'ETHUSDT', 'SOLUSDT', 'BNBUSDT', 'ADAUSDT'];
                updateAssetSuggestions();
            } catch (error) {
                console.error('Error fetching recent assets:', error);
            }
        }

        function setupAssetSuggestions() {
            const assetInput = document.getElementById('asset');
            assetInput.addEventListener('focus', updateAssetSuggestions);
        }

        function updateAssetSuggestions() {
            const container = document.getElementById('assetSuggestions');
            if (!container) return;

            if (appState.recentAssets.length === 0) {
                container.innerHTML = '';
                return;
            }

            const chips = appState.recentAssets.map(asset => 
                `<div class="chip" onclick="setAsset('${asset}')">${asset}</div>`
            ).join('');
            
            container.innerHTML = chips;
        }

        function setAsset(asset) {
            document.getElementById('asset').value = asset;
            validateAsset(asset);
            fetchPrice(asset);
            updateAssetSuggestions();
        }

        function validateAsset(symbol) {
            // Basic validation - in real app, call your market data service
            const isValid = symbol.length >= 5 && symbol.includes('USDT');
            const input = document.getElementById('asset');
            
            if (isValid) {
                input.style.borderColor = 'var(--green)';
                input.style.backgroundColor = 'rgba(50, 215, 75, 0.1)';
            } else {
                input.style.borderColor = 'var(--red)';
                input.style.backgroundColor = 'rgba(255, 69, 58, 0.1)';
            }
            
            return isValid;
        }

        async function fetchPrice(symbol) {
            if (!symbol) return;
            
            const priceElement = document.getElementById('livePrice');
            priceElement.textContent = '...';
            
            try {
                // Mock API call - replace with actual API
                // const response = await fetch(`/api/webapp/price?symbol=${symbol.toUpperCase()}`);
                // const data = await response.json();
                
                // Mock data for demonstration
                const mockPrices = {
                    'BTCUSDT': 90000 + (Math.random() * 1000 - 500),
                    'ETHUSDT': 3500 + (Math.random() * 50 - 25),
                    'SOLUSDT': 180 + (Math.random() * 5 - 2.5),
                    'BNBUSDT': 600 + (Math.random() * 10 - 5),
                    'ADAUSDT': 0.45 + (Math.random() * 0.1 - 0.05)
                };
                
                const price = mockPrices[symbol] || (90000 + Math.random() * 1000);
                appState.livePriceVal = price;
                priceElement.textContent = formatPrice(price);
                
                // Update entry price if market order
                if (appState.currentType === 'MARKET') {
                    document.getElementById('entry').value = price;
                    runFullValidation();
                }
            } catch (error) {
                console.error('Error fetching price:', error);
                priceElement.textContent = 'Ø®Ø·Ø£';
                priceElement.style.color = 'var(--red)';
            }
        }

        function debounceFetchPrice() {
            clearTimeout(appState.fetchTimeout);
            const symbol = document.getElementById('asset').value;
            if (symbol && validateAsset(symbol)) {
                appState.fetchTimeout = setTimeout(() => fetchPrice(symbol), 800);
            }
        }

        function startPriceUpdates() {
            // Update price every 30 seconds for current asset
            appState.priceUpdateInterval = setInterval(() => {
                const symbol = document.getElementById('asset').value;
                if (symbol && validateAsset(symbol)) {
                    fetchPrice(symbol);
                }
            }, 30000);
        }

        function formatPrice(price) {
            if (!price) return '0.00';
            const num = parseFloat(price);
            return num >= 1000 ? num.toFixed(2) : num.toFixed(4);
        }

        // ==============================================================================
        // 4. TRADE CONFIGURATION HANDLERS
        // ==============================================================================

        function setMarket(market) {
            appState.currentMarket = market;
            
            // Update UI
            document.querySelectorAll('.market-opt').forEach(opt => {
                opt.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Show/hide leverage section
            document.getElementById('leverageSection').style.display = 
                market === 'SPOT' ? 'none' : 'block';
                
            runFullValidation();
            tg.HapticFeedback.selectionChanged();
        }

        function setSide(side) {
            appState.currentSide = side;
            
            // Update UI
            document.querySelectorAll('.btn-select').forEach(btn => {
                btn.classList.remove('active-long', 'active-short');
            });
            event.target.classList.add(side === 'LONG' ? 'active-long' : 'active-short');
            
            runFullValidation();
            tg.HapticFeedback.selectionChanged();
        }

        function setType(type) {
            appState.currentType = type;
            
            // Update UI
            document.querySelectorAll('.btn-select').forEach(btn => {
                btn.classList.remove('active-type');
            });
            event.target.classList.add('active-type');
            
            // Handle input state
            const entryInput = document.getElementById('entry');
            const entryLabel = document.getElementById('entryLabel');
            
            if (type === 'MARKET') {
                entryInput.disabled = true;
                entryInput.value = appState.livePriceVal || '';
                entryInput.placeholder = "Ø³Ø¹Ø± Ø§Ù„Ø³ÙˆÙ‚ Ø§Ù„Ø­Ø§Ù„ÙŠ";
                entryLabel.textContent = "Ø³Ø¹Ø± Ø§Ù„Ø¯Ø®ÙˆÙ„ (Ø³ÙˆÙ‚)";
            } else {
                entryInput.disabled = false;
                entryInput.placeholder = "0.00";
                entryLabel.textContent = type === 'STOP' ? "Ø³Ø¹Ø± Ø§Ù„ØªÙ†ÙÙŠØ°" : "Ø³Ø¹Ø± Ø§Ù„Ø¯Ø®ÙˆÙ„";
            }
            
            runFullValidation();
            tg.HapticFeedback.selectionChanged();
        }

        function updateLeverage(value) {
            document.getElementById('levVal').textContent = value + 'x';
            runFullValidation();
        }

        // ==============================================================================
        // 5. TARGETS MANAGEMENT
        // ==============================================================================

        function addManualTarget() {
            const currentTotal = getTotalPercentage();
            const remaining = Math.max(0, 100 - currentTotal);
            
            addTargetRow('', remaining);
            tg.HapticFeedback.impactOccurred('light');
            runFullValidation();
        }

        function addTargetRow(price = "", percent = "") {
            appState.targetCount++;
            const container = document.getElementById('targetsContainer');
            const row = document.createElement('div');
            row.className = 'target-row';
            row.innerHTML = `
                <div class="tp-badge">${appState.targetCount}</div>
                <input type="number" class="tp-price" value="${price}" placeholder="Ø§Ù„Ø³Ø¹Ø±" 
                       oninput="runFullValidation()">
                <input type="number" class="tp-pct" value="${percent}" placeholder="%" 
                       oninput="runFullValidation()" style="width: 70px;">
                <div class="tp-remove" onclick="removeTarget(this)">Ã—</div>
            `;
            container.appendChild(row);
            runFullValidation();
        }

        function removeTarget(element) {
            element.parentElement.remove();
            appState.targetCount--;
            
            // Update badges
            document.querySelectorAll('.tp-badge').forEach((badge, index) => {
                badge.textContent = index + 1;
            });
            
            runFullValidation();
            tg.HapticFeedback.selectionChanged();
        }

        function smartCalc(percent) {
            const basePrice = getBasePrice();
            if (!basePrice) {
                tg.showAlert("âš ï¸ ÙŠØ±Ø¬Ù‰ ØªØ­Ø¯ÙŠØ¯ Ø³Ø¹Ø± Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø£ÙˆÙ„Ø§Ù‹");
                return;
            }
            
            const targetPrice = appState.currentSide === 'LONG' 
                ? basePrice * (1 + (percent / 100))
                : basePrice * (1 - (percent / 100));
                
            const currentTotal = getTotalPercentage();
            const remaining = Math.max(0, 100 - currentTotal);
            
            addTargetRow(targetPrice.toFixed(2), remaining);
            tg.HapticFeedback.impactOccurred('light');
            runFullValidation();
        }

        function promptCustomCalc() {
            const percent = prompt("Ø£Ø¯Ø®Ù„ Ø§Ù„Ù†Ø³Ø¨Ø© Ø§Ù„Ù…Ø¦ÙˆÙŠØ© (Ù…Ø«Ø§Ù„: 3.5):");
            if (percent && !isNaN(parseFloat(percent))) {
                smartCalc(parseFloat(percent));
            }
        }

        function calcRR(ratio) {
            const basePrice = getBasePrice();
            const slPrice = parseFloat(document.getElementById('sl').value);
            
            if (!basePrice || !slPrice) {
                tg.showAlert("âš ï¸ ÙŠØ±Ø¬Ù‰ ØªØ­Ø¯ÙŠØ¯ Ø³Ø¹Ø± Ø§Ù„Ø¯Ø®ÙˆÙ„ ÙˆÙˆÙ‚Ù Ø§Ù„Ø®Ø³Ø§Ø±Ø© Ø£ÙˆÙ„Ø§Ù‹");
                return;
            }
            
            const risk = Math.abs(basePrice - slPrice);
            const targetPrice = appState.currentSide === 'LONG' 
                ? basePrice + (risk * ratio)
                : basePrice - (risk * ratio);
                
            const currentTotal = getTotalPercentage();
            const remaining = Math.max(0, 100 - currentTotal);
            
            addTargetRow(targetPrice.toFixed(2), remaining);
            tg.HapticFeedback.impactOccurred('light');
            runFullValidation();
        }

        function getBasePrice() {
            if (appState.currentType === 'MARKET') {
                return appState.livePriceVal;
            }
            return parseFloat(document.getElementById('entry').value) || 0;
        }

        function getTotalPercentage() {
            let total = 0;
            document.querySelectorAll('.tp-pct').forEach(input => {
                total += parseFloat(input.value) || 0;
            });
            return total;
        }

        function updateTotalPercent() {
            const total = getTotalPercentage();
            const bar = document.getElementById('totalPercentBar');
            const text = document.getElementById('totalPercentText');
            
            bar.style.width = Math.min(total, 100) + '%';
            text.textContent = `Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹: ${total.toFixed(1)}%`;
            
            if (Math.abs(total - 100) < 0.1) {
                bar.style.background = 'var(--green)';
                text.style.color = 'var(--green)';
            } else {
                bar.style.background = 'linear-gradient(90deg, var(--orange), var(--green))';
                text.style.color = total > 100 ? 'var(--red)' : 'var(--orange)';
            }
        }

        // ==============================================================================
        // 6. VALIDATION ENGINE
        // ==============================================================================

        function runFullValidation() {
            updateCalculations();
            const isValid = validateTradeLogic();
            
            const submitBtn = document.getElementById('submitBtn');
            if (isValid) {
                submitBtn.disabled = false;
                submitBtn.style.opacity = "1";
                submitBtn.innerHTML = "ğŸš€ Ù†Ø´Ø± Ø§Ù„ØªÙˆØµÙŠØ©";
            } else {
                submitBtn.disabled = true;
                submitBtn.style.opacity = "0.5";
                submitBtn.innerHTML = "âš ï¸ ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª";
            }
            
            return isValid;
        }

        function validateTradeLogic() {
            let isValid = true;
            const entry = getBasePrice();
            const slInput = document.getElementById('sl');
            const sl = parseFloat(slInput.value);

            // 1. Validate Entry vs Stop Loss
            if (entry > 0 && sl > 0) {
                let slError = false;
                if (appState.currentSide === 'LONG' && sl >= entry) slError = true;
                if (appState.currentSide === 'SHORT' && sl <= entry) slError = true;

                if (slError) {
                    slInput.style.borderColor = 'var(--red)';
                    slInput.style.backgroundColor = 'rgba(255, 69, 58, 0.1)';
                    isValid = false;
                } else {
                    slInput.style.borderColor = 'rgba(255, 69, 58, 0.5)';
                    slInput.style.backgroundColor = 'var(--input-bg)';
                }
            }

            // 2. Validate Targets Sequence
            const rows = document.querySelectorAll('.target-row');
            let previousPrice = entry;

            rows.forEach(row => {
                const priceInput = row.querySelector('.tp-price');
                const price = parseFloat(priceInput.value);

                if (!price) return;

                let rowError = false;
                if (appState.currentSide === 'LONG') {
                    if (price <= previousPrice) rowError = true;
                } else {
                    if (price >= previousPrice && previousPrice > 0) rowError = true;
                }

                if (rowError) {
                    row.classList.add('error');
                    isValid = false;
                } else {
                    row.classList.remove('error');
                }
                previousPrice = price;
            });
            
            // 3. Validate Total Percentage
            const total = getTotalPercentage();
            if (Math.abs(total - 100) > 0.1) isValid = false;

            // 4. Validate Required Fields
            if (!document.getElementById('asset').value) isValid = false;
            if (appState.selectedChannels.size === 0) isValid = false;

            return isValid;
        }

        function updateCalculations() {
            const entry = getBasePrice();
            const sl = parseFloat(document.getElementById('sl').value) || 0;
            
            if (entry > 0 && sl > 0) {
                const diff = Math.abs(entry - sl);
                const pct = ((diff / entry) * 100).toFixed(2);
                document.getElementById('riskLabel').textContent = `-${pct}% Ù…Ø®Ø§Ø·Ø±Ø©`;
            }
            updateTotalPercent();
        }

        // ==============================================================================
        // 7. CHANNELS MANAGEMENT
        // ==============================================================================

        async function fetchChannels() {
            try {
                // Mock API call - replace with actual API
                // const initData = tg.initDataUnsafe ? JSON.stringify(tg.initDataUnsafe) : tg.initData;
                // const response = await fetch(`/api/webapp/channels?initData=${encodeURIComponent(initData)}`);
                // const data = await response.json();
                
                // Mock data for demonstration
                const mockChannels = [
                    { id: '1', title: 'Ø§Ù„Ù‚Ù†Ø§Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©', is_active: true },
                    { id: '2', title: 'Ø¥Ø´Ø§Ø±Ø§Øª VIP', is_active: true },
                    { id: '3', title: 'ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø³ÙˆÙ‚', is_active: true },
                    { id: '4', title: 'Ø§Ù„Ù‚Ù†Ø§Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©', is_active: false }
                ];
                
                const grid = document.getElementById('channelGrid');
                grid.innerHTML = '';
                
                mockChannels.forEach(channel => {
                    const chip = document.createElement('div');
                    chip.className = `channel-chip ${channel.is_active ? '' : 'inactive'}`;
                    chip.dataset.id = channel.id;
                    chip.innerHTML = `ğŸ“¢ ${channel.title}`;
                    chip.onclick = () => toggleChannel(channel.id, chip);
                    
                    // Select active channels by default
                    if (channel.is_active) {
                        appState.selectedChannels.add(channel.id);
                        chip.classList.add('selected');
                    }
                    
                    grid.appendChild(chip);
                });
                
                console.log(`âœ… Loaded ${mockChannels.length} channels`);
            } catch (error) {
                console.error('Error fetching channels:', error);
                document.getElementById('channelGrid').innerHTML = 
                    '<div class="channel-chip" style="grid-column: 1 / -1; color: var(--red);">âŒ Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù‚Ù†ÙˆØ§Øª</div>';
            }
        }

        function toggleChannel(channelId, element) {
            if (appState.selectedChannels.has(channelId)) {
                appState.selectedChannels.delete(channelId);
                element.classList.remove('selected');
            } else {
                appState.selectedChannels.add(channelId);
                element.classList.add('selected');
            }
            
            runFullValidation();
            tg.HapticFeedback.selectionChanged();
        }

        function toggleAllChannels() {
            const allChips = document.querySelectorAll('.channel-chip:not(.inactive)');
            const allSelected = allChips.length === appState.selectedChannels.size;
            
            allChips.forEach(chip => {
                const channelId = chip.dataset.id;
                
                if (allSelected) {
                    appState.selectedChannels.delete(channelId);
                    chip.classList.remove('selected');
                } else {
                    appState.selectedChannels.add(channelId);
                    chip.classList.add('selected');
                }
            });
            
            runFullValidation();
            tg.HapticFeedback.impactOccurred('medium');
        }

        // ==============================================================================
        // 8. TEXT INPUT PARSING
        // ==============================================================================

        function parseTextInput() {
            const method = appState.currentMethod;
            let inputText = '';
            
            if (method === 'quick') {
                inputText = document.getElementById('quickInput').value.trim();
            } else if (method === 'editor') {
                inputText = document.getElementById('editorInput').value.trim();
            }
            
            if (!inputText) {
                showAlert('âš ï¸ Ù…Ø¯Ø®Ù„Ø§Øª ÙØ§Ø±ØºØ©', 'ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø£ÙˆÙ„Ø§Ù‹', 'warning');
                return;
            }
            
            try {
                const parsedData = method === 'quick' 
                    ? parseQuickInput(inputText)
                    : parseEditorInput(inputText);
                    
                if (parsedData) {
                    applyParsedData(parsedData);
                    setupInputMethod('interactive');
                    showAlert('âœ… ØªÙ… Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø¨Ù†Ø¬Ø§Ø­', 'ØªÙ… ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ù†Ø¬Ø§Ø­', 'success');
                } else {
                    throw new Error('ØªÙ†Ø³ÙŠÙ‚ ØºÙŠØ± ØµØ§Ù„Ø­');
                }
            } catch (error) {
                showAlert('âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù„ÙŠÙ„', error.message, 'danger');
            }
        }

        function parseQuickInput(text) {
            const tokens = text.trim().split(/\s+/);
            if (tokens.length < 5) {
                throw new Error('Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± ÙƒØ§ÙÙŠØ©. Ø§Ù„ØªÙ†Ø³ÙŠÙ‚: Ø§Ù„Ø±Ù…Ø² Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø§Ù„ÙˆÙ‚Ù Ø§Ù„Ø£Ù‡Ø¯Ø§Ù...');
            }
            
            const asset = tokens[0].toUpperCase();
            const side = tokens[1].toUpperCase();
            const entry = parseFloat(tokens[2]);
            const sl = parseFloat(tokens[3]);
            const targets = tokens.slice(4).map(t => parseFloat(t)).filter(t => !isNaN(t));
            
            if (!['LONG', 'SHORT'].includes(side)) {
                throw new Error('Ø§Ù„Ø§ØªØ¬Ø§Ù‡ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† LONG Ø£Ùˆ SHORT');
            }
            
            if (isNaN(entry) || isNaN(sl) || targets.length === 0) {
                throw new Error('Ø£Ø³Ø¹Ø§Ø± ØºÙŠØ± ØµØ§Ù„Ø­Ø©');
            }
            
            return {
                asset,
                side,
                entry,
                stop_loss: sl,
                targets: targets.map((price, index) => ({
                    price,
                    close_percent: Math.floor(100 / targets.length)
                })),
                market: 'Futures',
                order_type: 'LIMIT'
            };
        }

        function parseEditorInput(text) {
            const lines = text.split('\n').map(line => line.trim()).filter(line => line);
            const data = {};
            
            lines.forEach(line => {
                const [key, ...valueParts] = line.split(':');
                if (key && valueParts.length > 0) {
                    const value = valueParts.join(':').trim();
                    const lowerKey = key.trim().toLowerCase();
                    
                    switch (lowerKey) {
                        case 'asset':
                            data.asset = value.toUpperCase();
                            break;
                        case 'side':
                            data.side = value.toUpperCase();
                            break;
                        case 'entry':
                            data.entry = parseFloat(value);
                            break;
                        case 'sl':
                        case 'stop loss':
                        case 'stop_loss':
                            data.stop_loss = parseFloat(value);
                            break;
                        case 'tps':
                        case 'targets':
                            data.targets = value.split(/\s+/)
                                .map(t => parseFloat(t))
                                .filter(t => !isNaN(t))
                                .map((price, index, arr) => ({
                                    price,
                                    close_percent: Math.floor(100 / arr.length)
                                }));
                            break;
                        case 'market':
                            data.market = value.charAt(0).toUpperCase() + value.slice(1).toLowerCase();
                            break;
                        case 'order type':
                        case 'order_type':
                            data.order_type = value.toUpperCase();
                            break;
                        case 'leverage':
                            data.leverage = value.replace('x', '');
                            break;
                        case 'notes':
                            data.notes = value;
                            break;
                    }
                }
            });
            
            // Validation
            if (!data.asset || !data.side || !data.entry || !data.stop_loss || !data.targets) {
                throw new Error('Ø¨ÙŠØ§Ù†Ø§Øª Ù†Ø§Ù‚ØµØ©. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯: Asset, Side, Entry, SL, TPs');
            }
            
            if (!['LONG', 'SHORT'].includes(data.side)) {
                throw new Error('Ø§Ù„Ø§ØªØ¬Ø§Ù‡ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† LONG Ø£Ùˆ SHORT');
            }
            
            data.market = data.market || 'Futures';
            data.order_type = data.order_type || 'LIMIT';
            
            return data;
        }

        function applyParsedData(parsedData) {
            // Set basic fields
            setAsset(parsedData.asset);
            setSide(parsedData.side);
            setType(parsedData.order_type);
            
            // Set market if provided
            if (parsedData.market) {
                const marketBtn = parsedData.market === 'Spot' ? document.querySelector('.market-opt:last-child') 
                                                              : document.querySelector('.market-opt:first-child');
                if (marketBtn) marketBtn.click();
            }
            
            // Set prices
            document.getElementById('entry').value = parsedData.entry;
            document.getElementById('sl').value = parsedData.stop_loss;
            
            // Set leverage if provided
            if (parsedData.leverage) {
                document.getElementById('leverage').value = parsedData.leverage;
                updateLeverage(parsedData.leverage);
            }
            
            // Set notes if provided
            if (parsedData.notes) {
                document.getElementById('notes').value = parsedData.notes;
            }
            
            // Clear existing targets and add new ones
            document.getElementById('targetsContainer').innerHTML = '';
            appState.targetCount = 0;
            
            parsedData.targets.forEach(target => {
                addTargetRow(target.price, target.close_percent);
            });
            
            runFullValidation();
        }

        // ==============================================================================
        // 9. PUBLICATION & API COMMUNICATION
        // ==============================================================================

        async function publishSignal() {
            if (!runFullValidation()) {
                tg.showAlert("âš ï¸ ÙŠØ±Ø¬Ù‰ ØªØµØ­ÙŠØ­ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø© ÙÙŠ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª");
                return;
            }

            const submitBtn = document.getElementById('submitBtn');
            submitBtn.disabled = true;
            submitBtn.classList.add('loading');
            submitBtn.innerHTML = "â³ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ù†Ø´Ø±...";
            
            tg.HapticFeedback.notificationOccurred('success');

            try {
                // Prepare targets
                const targets = [];
                document.querySelectorAll('.target-row').forEach(row => {
                    const price = row.querySelector('.tp-price').value;
                    const percent = row.querySelector('.tp-pct').value;
                    if (price) {
                        targets.push(percent ? `${price}@${percent}` : price);
                    }
                });

                // Prepare payload
                const payload = {
                    initData: tg.initDataUnsafe ? JSON.stringify(tg.initDataUnsafe) : tg.initData,
                    asset: document.getElementById('asset').value.toUpperCase(),
                    side: appState.currentSide,
                    market: appState.currentMarket,
                    order_type: appState.currentType,
                    entry: parseFloat(document.getElementById('entry').value) || 0,
                    stop_loss: parseFloat(document.getElementById('sl').value) || 0,
                    targets_raw: targets.join(' '),
                    notes: document.getElementById('notes').value,
                    leverage: document.getElementById('leverage').value,
                    channel_ids: Array.from(appState.selectedChannels)
                };

                // Mock API call - replace with actual API
                // const response = await fetch('/api/webapp/create', {
                //     method: 'POST',
                //     headers: {
                //         'Content-Type': 'application/json',
                //     },
                //     body: JSON.stringify(payload)
                // });

                // const data = await response.json();
                
                // Mock success response
                const mockResponse = { ok: true, id: 'SIG_' + Date.now() };

                if (mockResponse.ok) {
                    showAlert('âœ… Ù†Ø¬Ø§Ø­', `ØªÙ… Ù†Ø´Ø± Ø§Ù„ØªÙˆØµÙŠØ© Ø¨Ù†Ø¬Ø§Ø­ (ID: ${mockResponse.id})`, 'success');
                    setTimeout(() => {
                        tg.close();
                    }, 2000);
                } else {
                    throw new Error(mockResponse.error || 'Ø®Ø·Ø£ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ');
                }

            } catch (error) {
                console.error('Publication error:', error);
                showAlert('âŒ Ø®Ø·Ø£', error.message, 'danger');
                
                submitBtn.disabled = false;
                submitBtn.classList.remove('loading');
                submitBtn.innerHTML = "ğŸš€ Ù†Ø´Ø± Ø§Ù„ØªÙˆØµÙŠØ©";
            }
        }

        // ==============================================================================
        // 10. UI UTILITIES
        // ==============================================================================

        function showAlert(title, message, type) {
            const container = document.getElementById('alertContainer');
            const alert = document.createElement('div');
            alert.className = `alert alert-${type}`;
            alert.innerHTML = `
                <strong>${title}</strong>
                <div style="margin-top: 8px; font-size: 0.9rem;">${message}</div>
            `;
            
            container.appendChild(alert);
            
            // Auto remove after 5 seconds
            setTimeout(() => {
                if (alert.parentNode) {
                    alert.parentNode.removeChild(alert);
                }
            }, 5000);
        }

        function showLoading(show) {
            const overlay = document.getElementById('loadingOverlay');
            overlay.style.display = show ? 'flex' : 'none';
        }

        function getInitData() {
            return tg.initDataUnsafe ? JSON.stringify(tg.initDataUnsafe) : tg.initData;
        }

        // ==============================================================================
        // 11. INITIALIZATION
        // ==============================================================================

        // Initialize when DOM is loaded
        document.addEventListener('DOMContentLoaded', initializeApp);

        // Cleanup on unload
        window.addEventListener('beforeunload', () => {
            if (appState.priceUpdateInterval) {
                clearInterval(appState.priceUpdateInterval);
            }
        });

    </script>
</body>
</html>